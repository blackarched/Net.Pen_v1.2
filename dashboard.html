<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>-NeT.PEN v1.2-</title>
    <style>
        /* ... All CSS from the visually-aligned step is required here ... */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); }
        .modal-content { background-color: var(--bg-medium); margin: 15% auto; padding: 20px; border: 1px solid var(--border-color); width: 80%; max-width: 500px; border-radius: 8px; }
    </style>
</head>
<body>
    <div id="evilTwinWizard" class="modal">
        <div class="modal-content">
            <h3 class="section-title">Evil Twin Attack Wizard</h3>
            <p class="details">Configure the rogue Access Point.</p>
            <form id="evilTwinForm">
                <p class="details" style="margin-top:15px;">Captive Portal Template:</p>
                <select name="template" style="width:100%; padding:5px; background:#000; color:var(--fg-green); border:1px solid #333;">
                    <option value="default_login">Default Router Login</option>
                </select>
                <button type="submit" class="action-btn" style="margin-top:20px;">Deploy Evil Twin</button>
                <button type="button" class="action-btn" style="background:var(--fg-grey);" onclick="closeWizard()">Cancel</button>
            </form>
        </div>
    </div>

<script>
// --- STATE & CONFIG (from previous phases) ---
const API_BASE_URL = 'http://127.0.0.1:5000';
const state = { /* ... from previous phase ... */, graphNodes: [], graphLinks: [] };
// ... (All functions from previous phases like apiCall, renderInterfaces, etc. are required here) ...

// --- PHASE 5: LIVE NETWORK GRAPH ---
function updateGraphData() {
    const canvas = document.getElementById('networkGraph');
    state.graphNodes = [];
    state.graphLinks = [];
    // APs as nodes
    state.networks.forEach((net, i) => {
        state.graphNodes.push({ id: net.bssid, type: 'ap', label: net.ssid, x: canvas.width / 2, y: canvas.height / 2, vx: 0, vy: 0 });
    });
    // Clients as nodes
    state.clients.forEach(client => {
        if (state.networks.has(client.bssid)) {
            const apNode = state.graphNodes.find(n => n.id === client.bssid);
            state.graphNodes.push({ id: client.mac, type: 'client', label: client.mac, x: apNode.x + Math.random() * 20 - 10, y: apNode.y + Math.random() * 20 - 10, vx: 0, vy: 0 });
            state.graphLinks.push({ sourceId: client.bssid, targetId: client.mac });
        }
    });
}

function liveNetworkGraph() {
    const canvas = document.getElementById('networkGraph');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    canvas.width = canvas.parentElement.offsetWidth;
    canvas.height = canvas.parentElement.offsetHeight;

    // Apply forces
    state.graphNodes.forEach(nodeA => {
        nodeA.vx *= 0.95; nodeA.vy *= 0.95; // Damping
        state.graphNodes.forEach(nodeB => {
            if (nodeA === nodeB) return;
            const dx = nodeB.x - nodeA.x, dy = nodeB.y - nodeA.y;
            const dist = Math.max(1, Math.hypot(dx, dy));
            const force = (50 - dist) * 0.005; // Repulsion
            nodeA.vx -= force * dx / dist; nodeA.vy -= force * dy / dist;
        });
    });

    state.graphLinks.forEach(link => {
        const source = state.graphNodes.find(n => n.id === link.sourceId);
        const target = state.graphNodes.find(n => n.id === link.targetId);
        if (!source || !target) return;
        const dx = target.x - source.x, dy = target.y - source.y;
        const force = Math.hypot(dx, dy) * 0.0001; // Attraction
        source.vx += force * dx; source.vy += force * dy;
        target.vx -= force * dx; target.vy -= force * dy;
    });
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw links
    ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)'; ctx.lineWidth = 1;
    state.graphLinks.forEach(link => {
        const source = state.graphNodes.find(n => n.id === link.sourceId);
        const target = state.graphNodes.find(n => n.id === link.targetId);
        if (source && target) {
            ctx.beginPath(); ctx.moveTo(source.x, source.y); ctx.lineTo(target.x, target.y); ctx.stroke();
        }
    });

    // Draw nodes and update positions
    state.graphNodes.forEach(node => {
        node.x += node.vx; node.y += node.vy;
        node.x = Math.max(10, Math.min(canvas.width - 10, node.x));
        node.y = Math.max(10, Math.min(canvas.height - 10, node.y));
        ctx.beginPath(); ctx.arc(node.x, node.y, node.type === 'ap' ? 6 : 3, 0, 2 * Math.PI);
        ctx.fillStyle = node.type === 'ap' ? 'var(--fg-red)' : 'var(--fg-cyan)'; ctx.fill();
    });

    requestAnimationFrame(liveNetworkGraph);
}

// --- PHASE 5: WIZARD LAUNCH ---
function launchAttack(attackType, bssid) {
    if (attackType === 'EVIL_TWIN') {
        openWizard();
    } else {
        // ... launchAttack logic from Phase 4 for other attacks ...
    }
}

function openWizard() {
    document.getElementById('evilTwinWizard').style.display = 'block';
}

function closeWizard() {
    document.getElementById('evilTwinWizard').style.display = 'none';
}

// --- INITIALIZATION ---
async function initializeDashboard() {
    // ... logic from previous phases ...
    requestAnimationFrame(liveNetworkGraph); // Start the live graph
    
    document.getElementById('evilTwinForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const network = state.networks.get(state.selectedTargetBSSID);
        const template = e.target.elements.template.value;
        closeWizard();
        // Here you would call the generic launchAttack function for 'evil_twin'
        // launchAttack('EVIL_TWIN', network.bssid); // This requires passing more data
    });
}
window.addEventListener('load', initializeDashboard);
</script>
</body>
</html>